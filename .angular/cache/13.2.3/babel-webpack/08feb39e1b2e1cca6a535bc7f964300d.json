{"ast":null,"code":"import { Directive, ElementRef, Inject, HostBinding, Input, EventEmitter, Component, Renderer2, ViewChild, ContentChildren, Output, HostListener, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"contentRef\"];\nconst _c1 = [\"*\"];\nlet DragScrollItemDirective = /*#__PURE__*/(() => {\n  class DragScrollItemDirective {\n    constructor(elementRef) {\n      this.display = 'inline-block';\n      this._dragDisabled = false;\n      this._elementRef = elementRef;\n    }\n\n    get dragDisabled() {\n      return this._dragDisabled;\n    }\n\n    set dragDisabled(value) {\n      this._dragDisabled = value;\n    }\n\n  }\n\n  DragScrollItemDirective.ɵfac = function DragScrollItemDirective_Factory(t) {\n    return new (t || DragScrollItemDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef));\n  };\n\n  DragScrollItemDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: DragScrollItemDirective,\n    selectors: [[\"\", \"drag-scroll-item\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DragScrollItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.display);\n      }\n    },\n    inputs: {\n      dragDisabled: [\"drag-disabled\", \"dragDisabled\"]\n    }\n  });\n  return DragScrollItemDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DragScrollComponent = /*#__PURE__*/(() => {\n  class DragScrollComponent {\n    constructor(_elementRef, _renderer, _document) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._document = _document;\n      this._index = 0;\n      this._scrollbarHidden = false;\n      this._disabled = false;\n      this._xDisabled = false;\n      this._xWheelEnabled = false;\n      this._yDisabled = false;\n      this._dragDisabled = false;\n      this._snapDisabled = false;\n      this._snapOffset = 0;\n      this._snapDuration = 500;\n      this._isDragging = false;\n      /**\n       * Is the user currently pressing the element\n       */\n\n      this.isPressed = false;\n      /**\n       * Is the user currently scrolling the element\n       */\n\n      this.isScrolling = false;\n      this.scrollTimer = -1;\n      this.scrollToTimer = -1;\n      /**\n       * The x coordinates on the element\n       */\n\n      this.downX = 0;\n      /**\n       * The y coordinates on the element\n       */\n\n      this.downY = 0;\n      this.displayType = 'block';\n      this.elWidth = null;\n      this.elHeight = null;\n      this._pointerEvents = 'auto';\n      this.scrollbarWidth = null;\n      this.isAnimating = false;\n      this.prevChildrenLength = 0;\n      this.indexBound = 0;\n      this.dsInitialized = new EventEmitter();\n      this.indexChanged = new EventEmitter();\n      this.reachesLeftBound = new EventEmitter();\n      this.reachesRightBound = new EventEmitter();\n      this.snapAnimationFinished = new EventEmitter();\n      this.dragStart = new EventEmitter();\n      this.dragEnd = new EventEmitter();\n      this.scrollbarWidth = `${this.getScrollbarWidth()}px`;\n    }\n    /**\n     * Is the user currently dragging the element\n     */\n\n\n    get isDragging() {\n      return this._isDragging;\n    }\n\n    get currIndex() {\n      return this._index;\n    }\n\n    set currIndex(value) {\n      if (value !== this._index) {\n        this._index = value;\n        this.indexChanged.emit(value);\n      }\n    }\n    /**\n     * Whether the scrollbar is hidden\n     */\n\n\n    get scrollbarHidden() {\n      return this._scrollbarHidden;\n    }\n\n    set scrollbarHidden(value) {\n      this._scrollbarHidden = value;\n    }\n    /**\n     * Whether horizontally and vertically draging and scrolling is be disabled\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value;\n    }\n    /**\n     * Whether horizontally dragging and scrolling is be disabled\n     */\n\n\n    get xDisabled() {\n      return this._xDisabled;\n    }\n\n    set xDisabled(value) {\n      this._xDisabled = value;\n    }\n    /**\n     * Whether vertically dragging and scrolling events is disabled\n     */\n\n\n    get yDisabled() {\n      return this._yDisabled;\n    }\n\n    set yDisabled(value) {\n      this._yDisabled = value;\n    }\n    /**\n     * Whether scrolling horizontally with mouse wheel is enabled\n     */\n\n\n    get xWheelEnabled() {\n      return this._xWheelEnabled;\n    }\n\n    set xWheelEnabled(value) {\n      this._xWheelEnabled = value;\n    }\n\n    get dragDisabled() {\n      return this._dragDisabled;\n    }\n\n    set dragDisabled(value) {\n      this._dragDisabled = value;\n    }\n\n    get snapDisabled() {\n      return this._snapDisabled;\n    }\n\n    set snapDisabled(value) {\n      this._snapDisabled = value;\n    }\n\n    get snapOffset() {\n      return this._snapOffset;\n    }\n\n    set snapOffset(value) {\n      this._snapOffset = value;\n    }\n\n    get snapDuration() {\n      return this._snapDuration;\n    }\n\n    set snapDuration(value) {\n      this._snapDuration = value;\n    }\n\n    ngOnChanges() {\n      this.setScrollBar();\n\n      if (this.xDisabled || this.disabled || this._scrollbarHidden) {\n        this.disableScroll('x');\n      } else {\n        this.enableScroll('x');\n      }\n\n      if (this.yDisabled || this.disabled) {\n        this.disableScroll('y');\n      } else {\n        this.enableScroll('y');\n      }\n    }\n\n    ngAfterViewInit() {\n      // auto assign computed css\n      this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'true');\n\n      this.displayType = typeof window !== 'undefined' ? window.getComputedStyle(this._elementRef.nativeElement).display : 'block';\n\n      this._renderer.setStyle(this._contentRef.nativeElement, 'display', this.displayType);\n\n      this._renderer.setStyle(this._contentRef.nativeElement, 'whiteSpace', 'noWrap'); // store ele width height for later user\n\n\n      this.markElDimension();\n\n      this._renderer.setStyle(this._contentRef.nativeElement, 'width', this.elWidth);\n\n      this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.elHeight);\n\n      if (this.wrapper) {\n        this.checkScrollbar();\n      }\n\n      this._onMouseDownListener = this._renderer.listen(this._contentRef.nativeElement, 'mousedown', this.onMouseDownHandler.bind(this));\n      this._onScrollListener = this._renderer.listen(this._contentRef.nativeElement, 'scroll', this.onScrollHandler.bind(this)); // prevent Firefox from dragging images\n\n      this._onDragStartListener = this._renderer.listen(this._contentRef.nativeElement, 'dragstart', e => {\n        e.preventDefault();\n      });\n      this.checkNavStatus();\n      this.dsInitialized.emit();\n      this.adjustMarginToLastChild();\n    }\n\n    ngAfterViewChecked() {\n      // avoid extra checks\n      if (this._children.length !== this.prevChildrenLength) {\n        this.markElDimension();\n        this.checkScrollbar();\n        this.prevChildrenLength = this._children.length;\n        this.checkNavStatus();\n      }\n    }\n\n    ngOnDestroy() {\n      this._renderer.setAttribute(this._contentRef.nativeElement, 'drag-scroll', 'false');\n\n      if (this._onMouseDownListener) {\n        this._onMouseDownListener = this._onMouseDownListener();\n      }\n\n      if (this._onScrollListener) {\n        this._onScrollListener = this._onScrollListener();\n      }\n\n      if (this._onDragStartListener) {\n        this._onDragStartListener = this._onDragStartListener();\n      }\n    }\n\n    onMouseMoveHandler(event) {\n      this.onMouseMove(event);\n    }\n\n    onMouseMove(event) {\n      if (this.isPressed && !this.disabled) {\n        // Workaround for prevent scroll stuck if browser lost focus\n        // MouseEvent.buttons not support by Safari\n        // tslint:disable-next-line:deprecation\n        if (!event.buttons && !event.which) {\n          return this.onMouseUpHandler(event);\n        }\n\n        this._pointerEvents = 'none';\n\n        this._setIsDragging(true); // Drag X\n\n\n        if (!this.xDisabled && !this.dragDisabled) {\n          const clientX = event.clientX;\n          this._contentRef.nativeElement.scrollLeft = this._contentRef.nativeElement.scrollLeft - clientX + this.downX;\n          this.downX = clientX;\n        } // Drag Y\n\n\n        if (!this.yDisabled && !this.dragDisabled) {\n          const clientY = event.clientY;\n          this._contentRef.nativeElement.scrollTop = this._contentRef.nativeElement.scrollTop - clientY + this.downY;\n          this.downY = clientY;\n        }\n      }\n    }\n\n    onMouseDownHandler(event) {\n      const dragScrollItem = this.locateDragScrollItem(event.target);\n\n      if (dragScrollItem && dragScrollItem.dragDisabled) {\n        return;\n      }\n\n      const isTouchEvent = event.type === 'touchstart';\n\n      this._startGlobalListening(isTouchEvent);\n\n      this.isPressed = true;\n      const mouseEvent = event;\n      this.downX = mouseEvent.clientX;\n      this.downY = mouseEvent.clientY;\n      clearTimeout(this.scrollToTimer);\n    }\n\n    onScrollHandler() {\n      this.checkNavStatus();\n\n      if (!this.isPressed && !this.isAnimating && !this.snapDisabled) {\n        this.isScrolling = true;\n        clearTimeout(this.scrollTimer);\n        this.scrollTimer = setTimeout(() => {\n          this.isScrolling = false;\n          this.locateCurrentIndex(true);\n        }, 500);\n      } else {\n        this.locateCurrentIndex();\n      }\n    }\n\n    onMouseUpHandler(event) {\n      if (this.isPressed) {\n        this.isPressed = false;\n        this._pointerEvents = 'auto';\n\n        this._setIsDragging(false);\n\n        if (!this.snapDisabled) {\n          this.locateCurrentIndex(true);\n        } else {\n          this.locateCurrentIndex();\n        }\n\n        this._stopGlobalListening();\n      }\n    }\n    /*\n     * Nav button\n     */\n\n\n    moveLeft() {\n      if (this.currIndex !== 0 || this.snapDisabled) {\n        this.currIndex--;\n        clearTimeout(this.scrollToTimer);\n        this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n      }\n    }\n\n    moveRight() {\n      const container = this.wrapper || this.parentNode;\n      const containerWidth = container ? container.clientWidth : 0;\n\n      if (!this.isScrollReachesRightEnd() && this.currIndex < this.maximumIndex(containerWidth, this._children.toArray())) {\n        this.currIndex++;\n        clearTimeout(this.scrollToTimer);\n        this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n      }\n    }\n\n    moveTo(index) {\n      const container = this.wrapper || this.parentNode;\n      const containerWidth = container ? container.clientWidth : 0;\n\n      if (index >= 0 && index !== this.currIndex && this.currIndex <= this.maximumIndex(containerWidth, this._children.toArray())) {\n        this.currIndex = Math.min(index, this.maximumIndex(containerWidth, this._children.toArray()));\n        clearTimeout(this.scrollToTimer);\n        this.scrollTo(this._contentRef.nativeElement, this.toChildrenLocation(), this.snapDuration);\n      }\n    }\n\n    checkNavStatus() {\n      setTimeout(() => {\n        const onlyOneItem = Boolean(this._children.length <= 1);\n        const containerIsLargerThanContent = Boolean(this._contentRef.nativeElement.scrollWidth <= this._contentRef.nativeElement.clientWidth);\n\n        if (onlyOneItem || containerIsLargerThanContent) {\n          // only one element\n          this.reachesLeftBound.emit(true);\n          this.reachesRightBound.emit(true);\n        } else if (this.isScrollReachesRightEnd()) {\n          // reached right end\n          this.reachesLeftBound.emit(false);\n          this.reachesRightBound.emit(true);\n        } else if (this._contentRef.nativeElement.scrollLeft === 0 && this._contentRef.nativeElement.scrollWidth > this._contentRef.nativeElement.clientWidth) {\n          // reached left end\n          this.reachesLeftBound.emit(true);\n          this.reachesRightBound.emit(false);\n        } else {\n          // in the middle\n          this.reachesLeftBound.emit(false);\n          this.reachesRightBound.emit(false);\n        }\n      }, 0);\n    }\n\n    onWheel(event) {\n      if (this._xWheelEnabled) {\n        event.preventDefault();\n\n        if (this._snapDisabled) {\n          this._contentRef.nativeElement.scrollBy(event.deltaY, 0);\n        } else {\n          if (event.deltaY < 0) {\n            this.moveLeft();\n          } else if (event.deltaY > 0) {\n            this.moveRight();\n          }\n        }\n      }\n    }\n\n    onWindowResize() {\n      this.refreshWrapperDimensions();\n      this.checkNavStatus();\n    }\n\n    _setIsDragging(value) {\n      if (this._isDragging === value) {\n        return;\n      }\n\n      this._isDragging = value;\n      value ? this.dragStart.emit() : this.dragEnd.emit();\n    }\n\n    _startGlobalListening(isTouchEvent) {\n      if (!this._onMouseMoveListener) {\n        const eventName = isTouchEvent ? 'touchmove' : 'mousemove';\n        this._onMouseMoveListener = this._renderer.listen('document', eventName, this.onMouseMoveHandler.bind(this));\n      }\n\n      if (!this._onMouseUpListener) {\n        const eventName = isTouchEvent ? 'touchend' : 'mouseup';\n        this._onMouseUpListener = this._renderer.listen('document', eventName, this.onMouseUpHandler.bind(this));\n      }\n    }\n\n    _stopGlobalListening() {\n      if (this._onMouseMoveListener) {\n        this._onMouseMoveListener = this._onMouseMoveListener();\n      }\n\n      if (this._onMouseUpListener) {\n        this._onMouseUpListener = this._onMouseUpListener();\n      }\n    }\n\n    disableScroll(axis) {\n      this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'hidden');\n    }\n\n    enableScroll(axis) {\n      this._renderer.setStyle(this._contentRef.nativeElement, `overflow-${axis}`, 'auto');\n    }\n\n    hideScrollbar() {\n      if (this._contentRef.nativeElement.style.display !== 'none' && !this.wrapper) {\n        this.parentNode = this._contentRef.nativeElement.parentNode; // create container element\n\n        this.wrapper = this._renderer.createElement('div');\n\n        this._renderer.setAttribute(this.wrapper, 'class', 'drag-scroll-wrapper');\n\n        this._renderer.addClass(this.wrapper, 'drag-scroll-container');\n\n        this.refreshWrapperDimensions();\n\n        this._renderer.setStyle(this.wrapper, 'overflow', 'hidden');\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`); // Append container element to component element.\n\n\n        this._renderer.appendChild(this._elementRef.nativeElement, this.wrapper); // Append content element to container element.\n\n\n        this._renderer.appendChild(this.wrapper, this._contentRef.nativeElement);\n\n        this.adjustMarginToLastChild();\n      }\n    }\n\n    showScrollbar() {\n      if (this.wrapper) {\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', this.wrapper.style.height);\n\n        if (this.parentNode !== null) {\n          this.parentNode.removeChild(this.wrapper);\n          this.parentNode.appendChild(this._contentRef.nativeElement);\n        }\n\n        this.wrapper = null;\n        this.adjustMarginToLastChild();\n      }\n    }\n\n    checkScrollbar() {\n      if (this._contentRef.nativeElement.scrollWidth <= this._contentRef.nativeElement.clientWidth) {\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', '100%');\n      } else {\n        this._renderer.setStyle(this._contentRef.nativeElement, 'height', `calc(100% + ${this.scrollbarWidth})`);\n      }\n\n      if (this._contentRef.nativeElement.scrollHeight <= this._contentRef.nativeElement.clientHeight) {\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', '100%');\n      } else {\n        this._renderer.setStyle(this._contentRef.nativeElement, 'width', `calc(100% + ${this.scrollbarWidth})`);\n      }\n    }\n\n    setScrollBar() {\n      if (this.scrollbarHidden) {\n        this.hideScrollbar();\n      } else {\n        this.showScrollbar();\n      }\n    }\n\n    getScrollbarWidth() {\n      /**\n       * Browser Scrollbar Widths (2016)\n       * OSX (Chrome, Safari, Firefox) - 15px\n       * Windows XP (IE7, Chrome, Firefox) - 17px\n       * Windows 7 (IE10, IE11, Chrome, Firefox) - 17px\n       * Windows 8.1 (IE11, Chrome, Firefox) - 17px\n       * Windows 10 (IE11, Chrome, Firefox) - 17px\n       * Windows 10 (Edge 12/13) - 12px\n       */\n      const outer = this._renderer.createElement('div');\n\n      this._renderer.setStyle(outer, 'visibility', 'hidden');\n\n      this._renderer.setStyle(outer, 'width', '100px');\n\n      this._renderer.setStyle(outer, 'msOverflowStyle', 'scrollbar'); // needed for WinJS apps\n      // document.body.appendChild(outer);\n\n\n      this._renderer.appendChild(this._document.body, outer); // this._renderer.appendChild(this._renderer.selectRootElement('body'), outer);\n\n\n      const widthNoScroll = outer.offsetWidth; // force scrollbars\n\n      this._renderer.setStyle(outer, 'overflow', 'scroll'); // add innerdiv\n\n\n      const inner = this._renderer.createElement('div');\n\n      this._renderer.setStyle(inner, 'width', '100%');\n\n      this._renderer.appendChild(outer, inner);\n\n      const widthWithScroll = inner.offsetWidth; // remove divs\n\n      this._renderer.removeChild(this._document.body, outer);\n      /**\n       * Scrollbar width will be 0 on Mac OS with the\n       * default \"Only show scrollbars when scrolling\" setting (Yosemite and up).\n       * setting default width to 20;\n       */\n\n\n      return widthNoScroll - widthWithScroll || 20;\n    }\n\n    refreshWrapperDimensions() {\n      if (this.wrapper) {\n        this._renderer.setStyle(this.wrapper, 'width', '100%');\n\n        this._renderer.setStyle(this.wrapper, 'height', this._elementRef.nativeElement.style.height || this._elementRef.nativeElement.offsetHeight + 'px');\n      }\n    }\n    /*\n    * The below solution is heavily inspired from\n    * https://gist.github.com/andjosh/6764939\n    */\n\n\n    scrollTo(element, to, duration) {\n      const self = this;\n      self.isAnimating = true;\n      const start = element.scrollLeft,\n            change = to - start - this.snapOffset,\n            increment = 20;\n      let currentTime = 0; // t = current time\n      // b = start value\n      // c = change in value\n      // d = duration\n\n      const easeInOutQuad = function (t, b, c, d) {\n        t /= d / 2;\n\n        if (t < 1) {\n          return c / 2 * t * t + b;\n        }\n\n        t--;\n        return -c / 2 * (t * (t - 2) - 1) + b;\n      };\n\n      const animateScroll = function () {\n        currentTime += increment;\n        element.scrollLeft = easeInOutQuad(currentTime, start, change, duration);\n\n        if (currentTime < duration) {\n          self.scrollToTimer = setTimeout(animateScroll, increment);\n        } else {\n          // run one more frame to make sure the animation is fully finished\n          setTimeout(() => {\n            self.isAnimating = false;\n            self.snapAnimationFinished.emit(self.currIndex);\n          }, increment);\n        }\n      };\n\n      animateScroll();\n    }\n\n    locateCurrentIndex(snap) {\n      this.currentChildWidth((currentChildWidth, nextChildrenWidth, childrenWidth, idx, stop) => {\n        if (this._contentRef.nativeElement.scrollLeft >= childrenWidth && this._contentRef.nativeElement.scrollLeft <= nextChildrenWidth) {\n          if (nextChildrenWidth - this._contentRef.nativeElement.scrollLeft > currentChildWidth / 2 && !this.isScrollReachesRightEnd()) {\n            // roll back scrolling\n            if (!this.isAnimating) {\n              this.currIndex = idx;\n            }\n\n            if (snap) {\n              this.scrollTo(this._contentRef.nativeElement, childrenWidth, this.snapDuration);\n            }\n          } else if (this._contentRef.nativeElement.scrollLeft !== 0) {\n            // forward scrolling\n            if (!this.isAnimating) {\n              this.currIndex = idx + 1;\n            }\n\n            if (snap) {\n              this.scrollTo(this._contentRef.nativeElement, childrenWidth + currentChildWidth, this.snapDuration);\n            }\n          }\n\n          stop();\n        } else if (idx + 1 === this._children.length - 1) {\n          // reaches last index\n          if (!this.isAnimating) {\n            this.currIndex = idx + 1;\n          }\n\n          stop();\n        }\n      });\n    }\n\n    currentChildWidth(cb) {\n      let childrenWidth = 0;\n      let shouldBreak = false;\n\n      const breakFunc = function () {\n        shouldBreak = true;\n      };\n\n      const childrenArr = this._children.toArray();\n\n      for (let i = 0; i < childrenArr.length; i++) {\n        if (i === childrenArr.length - 1) {\n          break;\n        }\n\n        if (shouldBreak) {\n          break;\n        }\n\n        const nextChildrenWidth = childrenWidth + childrenArr[i + 1]._elementRef.nativeElement.clientWidth;\n        const currentClildWidth = childrenArr[i]._elementRef.nativeElement.clientWidth;\n        cb(currentClildWidth, nextChildrenWidth, childrenWidth, i, breakFunc);\n        childrenWidth += currentClildWidth;\n      }\n    }\n\n    toChildrenLocation() {\n      let to = 0;\n\n      const childrenArr = this._children.toArray();\n\n      for (let i = 0; i < this.currIndex; i++) {\n        to += childrenArr[i]._elementRef.nativeElement.clientWidth;\n      }\n\n      return to;\n    }\n\n    locateDragScrollItem(element) {\n      let item = null;\n\n      const childrenArr = this._children.toArray();\n\n      for (let i = 0; i < childrenArr.length; i++) {\n        if (element === childrenArr[i]._elementRef.nativeElement) {\n          item = childrenArr[i];\n        }\n      }\n\n      return item;\n    }\n\n    markElDimension() {\n      if (this.wrapper) {\n        this.elWidth = this.wrapper.style.width;\n        this.elHeight = this.wrapper.style.height;\n      } else {\n        this.elWidth = this._elementRef.nativeElement.style.width || this._elementRef.nativeElement.offsetWidth + 'px';\n        this.elHeight = this._elementRef.nativeElement.style.height || this._elementRef.nativeElement.offsetHeight + 'px';\n      }\n\n      const container = this.wrapper || this.parentNode;\n      const containerWidth = container ? container.clientWidth : 0;\n\n      if (this._children.length > 1) {\n        this.indexBound = this.maximumIndex(containerWidth, this._children.toArray());\n      }\n    }\n\n    maximumIndex(containerWidth, childrenElements) {\n      let count = 0;\n      let childrenWidth = 0;\n\n      for (let i = 0; i <= childrenElements.length; i++) {\n        // last N element\n        const dragScrollItemDirective = childrenElements[childrenElements.length - 1 - i];\n\n        if (!dragScrollItemDirective) {\n          break;\n        } else {\n          const nativeElement = dragScrollItemDirective._elementRef.nativeElement;\n          let itemWidth = nativeElement.clientWidth;\n\n          if (itemWidth === 0 && nativeElement.firstElementChild) {\n            itemWidth = dragScrollItemDirective._elementRef.nativeElement.firstElementChild.clientWidth;\n          }\n\n          childrenWidth += itemWidth;\n\n          if (childrenWidth < containerWidth) {\n            count++;\n          } else {\n            break;\n          }\n        }\n      }\n\n      return childrenElements.length - count;\n    }\n\n    isScrollReachesRightEnd() {\n      const scrollLeftPos = this._contentRef.nativeElement.scrollLeft + this._contentRef.nativeElement.offsetWidth;\n      return scrollLeftPos >= this._contentRef.nativeElement.scrollWidth;\n    }\n    /**\n     * adds a margin right style to the last child element which will resolve the issue\n     * of last item gets cutoff.\n     */\n\n\n    adjustMarginToLastChild() {\n      if (this._children && this._children.length > 0 && this.hideScrollbar) {\n        const childrenArr = this._children.toArray();\n\n        const lastItem = childrenArr[childrenArr.length - 1]._elementRef.nativeElement;\n\n        if (this.wrapper && childrenArr.length > 1) {\n          this._renderer.setStyle(lastItem, 'margin-right', this.scrollbarWidth);\n        } else {\n          this._renderer.setStyle(lastItem, 'margin-right', 0);\n        }\n      }\n    }\n\n  }\n\n  DragScrollComponent.ɵfac = function DragScrollComponent_Factory(t) {\n    return new (t || DragScrollComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer2), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  DragScrollComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: DragScrollComponent,\n    selectors: [[\"drag-scroll\"]],\n    contentQueries: function DragScrollComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, DragScrollItemDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._children = _t);\n      }\n    },\n    viewQuery: function DragScrollComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._contentRef = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function DragScrollComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"wheel\", function DragScrollComponent_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        })(\"resize\", function DragScrollComponent_resize_HostBindingHandler() {\n          return ctx.onWindowResize();\n        }, false, ɵngcc0.ɵɵresolveWindow);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"pointer-events\", ctx._pointerEvents);\n      }\n    },\n    inputs: {\n      scrollbarHidden: [\"scrollbar-hidden\", \"scrollbarHidden\"],\n      disabled: [\"drag-scroll-disabled\", \"disabled\"],\n      xDisabled: [\"drag-scroll-x-disabled\", \"xDisabled\"],\n      yDisabled: [\"drag-scroll-y-disabled\", \"yDisabled\"],\n      xWheelEnabled: [\"scroll-x-wheel-enabled\", \"xWheelEnabled\"],\n      dragDisabled: [\"drag-disabled\", \"dragDisabled\"],\n      snapDisabled: [\"snap-disabled\", \"snapDisabled\"],\n      snapOffset: [\"snap-offset\", \"snapOffset\"],\n      snapDuration: [\"snap-duration\", \"snapDuration\"]\n    },\n    outputs: {\n      dsInitialized: \"dsInitialized\",\n      indexChanged: \"indexChanged\",\n      reachesLeftBound: \"reachesLeftBound\",\n      reachesRightBound: \"reachesRightBound\",\n      snapAnimationFinished: \"snapAnimationFinished\",\n      dragStart: \"dragStart\",\n      dragEnd: \"dragEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[1, \"drag-scroll-content\"], [\"contentRef\", \"\"]],\n    template: function DragScrollComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    styles: [\"[_nghost-%COMP%] {\\n      overflow: hidden;\\n      display: block;\\n    }\\n    .drag-scroll-content[_ngcontent-%COMP%] {\\n      height: 100%;\\n      overflow: auto;\\n      white-space: nowrap;\\n    }\"]\n  });\n  return DragScrollComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DragScrollModule = /*#__PURE__*/(() => {\n  class DragScrollModule {}\n\n  DragScrollModule.ɵfac = function DragScrollModule_Factory(t) {\n    return new (t || DragScrollModule)();\n  };\n\n  DragScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: DragScrollModule\n  });\n  DragScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return DragScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragScrollModule, {\n    declarations: [DragScrollComponent, DragScrollItemDirective],\n    exports: [DragScrollComponent, DragScrollItemDirective]\n  });\n})();\n/*\n * Public API Surface of ngx-drag-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DragScrollComponent, DragScrollItemDirective, DragScrollModule }; //# sourceMappingURL=ngx-drag-scroll.js.map","map":null,"metadata":{},"sourceType":"module"}