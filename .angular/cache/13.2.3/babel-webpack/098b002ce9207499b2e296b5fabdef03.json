{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { empty, merge, Subject } from 'rxjs';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const promiseGlobalCacheBusterNotifier = new Subject();\n\nconst getResponse = (oldMethod, cacheKey, cacheConfig, context, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation) => {\n  let cacheParameters = cacheConfig.cacheHasher(parameters);\n\n  let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n  const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n  /**\n   * check if maxAge is passed and cache has actually expired\n   */\n\n\n  if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n    if (new Date().getTime() - new Date(_foundCachePair.created).getTime() > (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n      /**\n       * cache duration has expired - remove it from the cachePairs array\n       */\n      storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n      _foundCachePair = null;\n    } else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n      /**\n       * renew cache duration\n       */\n      _foundCachePair.created = new Date();\n      storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n    }\n  }\n\n  if (_foundCachePair) {\n    return promiseImplementation.resolve(_foundCachePair.response);\n  } else if (_foundPendingCachePair) {\n    return _foundPendingCachePair.response;\n  } else {\n    const response$ = oldMethod.call(context, ...parameters).then(response => {\n      removeCachePair(pendingCachePairs, parameters, cacheConfig);\n      /**\n       * if no maxCacheCount has been passed\n       * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n       * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n       */\n\n      if (!cacheConfig.shouldCacheDecider || cacheConfig.shouldCacheDecider(response)) {\n        if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) && (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1) {\n          storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n        }\n\n        storageStrategy.add({\n          parameters: cacheParameters,\n          response,\n          created: cacheConfig.maxAge || GlobalCacheConfig.maxAge ? new Date() : null\n        }, cacheKey, this);\n      }\n\n      return response;\n    }).catch(error => {\n      removeCachePair(pendingCachePairs, parameters, cacheConfig);\n      return promiseImplementation.reject(error);\n    });\n    /**\n     * cache the stream\n     */\n\n    pendingCachePairs.push({\n      parameters: cacheParameters,\n      response: response$,\n      created: new Date()\n    });\n    return response$;\n  }\n};\n\nconst removeCachePair = (cachePairs, parameters, cacheConfig) => {\n  const cacheParameters = cacheConfig.cacheHasher(parameters);\n  /**\n   * if there has been an pending cache pair for these parameters, when it completes or errors, remove it\n   */\n\n  const _pendingCachePairToRemove = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n  cachePairs.splice(cachePairs.indexOf(_pendingCachePairToRemove), 1);\n};\n\nexport function PCacheable(cacheConfig = {}) {\n  return function (_target, _propertyKey, propertyDescriptor) {\n    const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n    const oldMethod = propertyDescriptor.value;\n\n    if (propertyDescriptor && propertyDescriptor.value) {\n      let storageStrategy = !cacheConfig.storageStrategy ? new GlobalCacheConfig.storageStrategy() : new cacheConfig.storageStrategy();\n      const pendingCachePairs = [];\n\n      if (cacheConfig.cacheModifier) {\n        cacheConfig.cacheModifier.subscribe(callback => __awaiter(this, void 0, void 0, function* () {\n          return storageStrategy.addMany(callback(yield storageStrategy.getAll(cacheKey, this)), cacheKey, this);\n        }));\n      }\n      /**\n       * subscribe to the promiseGlobalCacheBusterNotifier\n       * if a custom cacheBusterObserver is passed, subscribe to it as well\n       * subscribe to the cacheBusterObserver and upon emission, clear all caches\n       */\n\n\n      merge(promiseGlobalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver ? cacheConfig.cacheBusterObserver : empty()).subscribe(_ => {\n        storageStrategy.removeAll(cacheKey, this);\n        pendingCachePairs.length = 0;\n      });\n      const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n      cacheConfig.cacheResolver = cacheResolver ? cacheResolver : DEFAULT_CACHE_RESOLVER;\n      const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n      cacheConfig.cacheHasher = cacheHasher ? cacheHasher : DEFAULT_HASHER;\n      /* use function instead of an arrow function to keep context of invocation */\n\n      propertyDescriptor.value = function (...parameters) {\n        const promiseImplementation = typeof GlobalCacheConfig.promiseImplementation === 'function' && GlobalCacheConfig.promiseImplementation !== Promise ? GlobalCacheConfig.promiseImplementation.call(this) : GlobalCacheConfig.promiseImplementation;\n        let cachePairs = storageStrategy.getAll(cacheKey, this);\n\n        if (!(cachePairs instanceof promiseImplementation)) {\n          cachePairs = promiseImplementation.resolve(cachePairs);\n        }\n\n        return cachePairs.then(cachePairs => getResponse(oldMethod, cacheKey, cacheConfig, this, cachePairs, parameters, pendingCachePairs, storageStrategy, promiseImplementation));\n      };\n    }\n\n    return propertyDescriptor;\n  };\n}\n; //# sourceMappingURL=promise.cacheable.decorator.js.map","map":null,"metadata":{},"sourceType":"module"}