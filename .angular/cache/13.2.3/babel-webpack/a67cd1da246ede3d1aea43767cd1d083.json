{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { EventEmitter, ElementRef, Renderer2, NgZone, ChangeDetectorRef, Inject, PLATFORM_ID, Optional, Input, Output, ViewChild, ContentChild, Component, NgModule } from '@angular/core';\nimport { isPlatformServer, CommonModule } from '@angular/common';\nimport { Tween, Easing } from '@tweenjs/tween.js';\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"header\"];\nconst _c1 = [\"container\"];\nconst _c2 = [\"content\"];\nconst _c3 = [\"invisiblePadding\"];\nconst _c4 = [\"*\"];\n\nfunction VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    scrollThrottlingTime: 0,\n    scrollDebounceTime: 0,\n    scrollAnimationTime: 750,\n    checkResizeInterval: 1000,\n    resizeBypassRefreshThreshold: 5,\n    modifyOverflowStyleOfParentScroll: true,\n    stripedTable: false\n  };\n}\n\nlet VirtualScrollerComponent = class VirtualScrollerComponent {\n  constructor(element, renderer, zone, changeDetectorRef, platformId, options) {\n    this.element = element;\n    this.renderer = renderer;\n    this.zone = zone;\n    this.changeDetectorRef = changeDetectorRef;\n    this.window = window;\n    this.executeRefreshOutsideAngularZone = false;\n    this._enableUnequalChildrenSizes = false;\n    this.RTL = false;\n    this.useMarginInsteadOfTranslate = false;\n    this.ssrViewportWidth = 1920;\n    this.ssrViewportHeight = 1080;\n    this._items = [];\n\n    this.compareItems = (item1, item2) => item1 === item2;\n\n    this.vsUpdate = new EventEmitter();\n    this.vsChange = new EventEmitter();\n    this.vsStart = new EventEmitter();\n    this.vsEnd = new EventEmitter();\n    this.calculatedScrollbarWidth = 0;\n    this.calculatedScrollbarHeight = 0;\n    this.padding = 0;\n    this.previousViewPort = {};\n    this.cachedPageSize = 0;\n    this.previousScrollNumberElements = 0;\n    this.isAngularUniversalSSR = isPlatformServer(platformId);\n    this.scrollThrottlingTime = options.scrollThrottlingTime;\n    this.scrollDebounceTime = options.scrollDebounceTime;\n    this.scrollAnimationTime = options.scrollAnimationTime;\n    this.scrollbarWidth = options.scrollbarWidth;\n    this.scrollbarHeight = options.scrollbarHeight;\n    this.checkResizeInterval = options.checkResizeInterval;\n    this.resizeBypassRefreshThreshold = options.resizeBypassRefreshThreshold;\n    this.modifyOverflowStyleOfParentScroll = options.modifyOverflowStyleOfParentScroll;\n    this.stripedTable = options.stripedTable;\n    this.horizontal = false;\n    this.resetWrapGroupDimensions();\n  }\n\n  get viewPortInfo() {\n    let pageInfo = this.previousViewPort || {};\n    return {\n      startIndex: pageInfo.startIndex || 0,\n      endIndex: pageInfo.endIndex || 0,\n      scrollStartPosition: pageInfo.scrollStartPosition || 0,\n      scrollEndPosition: pageInfo.scrollEndPosition || 0,\n      maxScrollPosition: pageInfo.maxScrollPosition || 0,\n      startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,\n      endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0\n    };\n  }\n\n  get enableUnequalChildrenSizes() {\n    return this._enableUnequalChildrenSizes;\n  }\n\n  set enableUnequalChildrenSizes(value) {\n    if (this._enableUnequalChildrenSizes === value) {\n      return;\n    }\n\n    this._enableUnequalChildrenSizes = value;\n    this.minMeasuredChildWidth = undefined;\n    this.minMeasuredChildHeight = undefined;\n  }\n\n  get bufferAmount() {\n    if (typeof this._bufferAmount === 'number' && this._bufferAmount >= 0) {\n      return this._bufferAmount;\n    } else {\n      return this.enableUnequalChildrenSizes ? 5 : 0;\n    }\n  }\n\n  set bufferAmount(value) {\n    this._bufferAmount = value;\n  }\n\n  get scrollThrottlingTime() {\n    return this._scrollThrottlingTime;\n  }\n\n  set scrollThrottlingTime(value) {\n    this._scrollThrottlingTime = value;\n    this.updateOnScrollFunction();\n  }\n\n  get scrollDebounceTime() {\n    return this._scrollDebounceTime;\n  }\n\n  set scrollDebounceTime(value) {\n    this._scrollDebounceTime = value;\n    this.updateOnScrollFunction();\n  }\n\n  updateOnScrollFunction() {\n    if (this.scrollDebounceTime) {\n      this.onScroll = this.debounce(() => {\n        this.refresh_internal(false);\n      }, this.scrollDebounceTime);\n    } else if (this.scrollThrottlingTime) {\n      this.onScroll = this.throttleTrailing(() => {\n        this.refresh_internal(false);\n      }, this.scrollThrottlingTime);\n    } else {\n      this.onScroll = () => {\n        this.refresh_internal(false);\n      };\n    }\n  }\n\n  get checkResizeInterval() {\n    return this._checkResizeInterval;\n  }\n\n  set checkResizeInterval(value) {\n    if (this._checkResizeInterval === value) {\n      return;\n    }\n\n    this._checkResizeInterval = value;\n    this.addScrollEventHandlers();\n  }\n\n  get items() {\n    return this._items;\n  }\n\n  set items(value) {\n    if (value === this._items) {\n      return;\n    }\n\n    this._items = value || [];\n    this.refresh_internal(true);\n  }\n\n  get horizontal() {\n    return this._horizontal;\n  }\n\n  set horizontal(value) {\n    this._horizontal = value;\n    this.updateDirection();\n  }\n\n  revertParentOverscroll() {\n    const scrollElement = this.getScrollElement();\n\n    if (scrollElement && this.oldParentScrollOverflow) {\n      scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;\n      scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;\n    }\n\n    this.oldParentScrollOverflow = undefined;\n  }\n\n  get parentScroll() {\n    return this._parentScroll;\n  }\n\n  set parentScroll(value) {\n    if (this._parentScroll === value) {\n      return;\n    }\n\n    this.revertParentOverscroll();\n    this._parentScroll = value;\n    this.addScrollEventHandlers();\n    const scrollElement = this.getScrollElement();\n\n    if (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {\n      this.oldParentScrollOverflow = {\n        x: scrollElement.style['overflow-x'],\n        y: scrollElement.style['overflow-y']\n      };\n      scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';\n      scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';\n    }\n  }\n\n  ngOnInit() {\n    this.addScrollEventHandlers();\n  }\n\n  ngOnDestroy() {\n    this.removeScrollEventHandlers();\n    this.revertParentOverscroll();\n  }\n\n  ngOnChanges(changes) {\n    let indexLengthChanged = this.cachedItemsLength !== this.items.length;\n    this.cachedItemsLength = this.items.length;\n    const firstRun = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0;\n    this.refresh_internal(indexLengthChanged || firstRun);\n  }\n\n  ngDoCheck() {\n    if (this.cachedItemsLength !== this.items.length) {\n      this.cachedItemsLength = this.items.length;\n      this.refresh_internal(true);\n      return;\n    }\n\n    if (this.previousViewPort && this.viewPortItems && this.viewPortItems.length > 0) {\n      let itemsArrayChanged = false;\n\n      for (let i = 0; i < this.viewPortItems.length; ++i) {\n        if (!this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])) {\n          itemsArrayChanged = true;\n          break;\n        }\n      }\n\n      if (itemsArrayChanged) {\n        this.refresh_internal(true);\n      }\n    }\n  }\n\n  refresh() {\n    this.refresh_internal(true);\n  }\n\n  invalidateAllCachedMeasurements() {\n    this.wrapGroupDimensions = {\n      maxChildSizePerWrapGroup: [],\n      numberOfKnownWrapGroupChildSizes: 0,\n      sumOfKnownWrapGroupChildWidths: 0,\n      sumOfKnownWrapGroupChildHeights: 0\n    };\n    this.minMeasuredChildWidth = undefined;\n    this.minMeasuredChildHeight = undefined;\n    this.refresh_internal(false);\n  }\n\n  invalidateCachedMeasurementForItem(item) {\n    if (this.enableUnequalChildrenSizes) {\n      let index = this.items && this.items.indexOf(item);\n\n      if (index >= 0) {\n        this.invalidateCachedMeasurementAtIndex(index);\n      }\n    } else {\n      this.minMeasuredChildWidth = undefined;\n      this.minMeasuredChildHeight = undefined;\n    }\n\n    this.refresh_internal(false);\n  }\n\n  invalidateCachedMeasurementAtIndex(index) {\n    if (this.enableUnequalChildrenSizes) {\n      let cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];\n\n      if (cachedMeasurement) {\n        this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;\n        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;\n      }\n    } else {\n      this.minMeasuredChildWidth = undefined;\n      this.minMeasuredChildHeight = undefined;\n    }\n\n    this.refresh_internal(false);\n  }\n\n  scrollInto(item, alignToBeginning = true, additionalOffset = 0, animationMilliseconds = undefined, animationCompletedCallback = undefined) {\n    let index = this.items.indexOf(item);\n\n    if (index === -1) {\n      return;\n    }\n\n    this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);\n  }\n\n  scrollToIndex(index, alignToBeginning = true, additionalOffset = 0, animationMilliseconds = undefined, animationCompletedCallback = undefined) {\n    let maxRetries = 5;\n\n    let retryIfNeeded = () => {\n      --maxRetries;\n\n      if (maxRetries <= 0) {\n        if (animationCompletedCallback) {\n          animationCompletedCallback();\n        }\n\n        return;\n      }\n\n      let dimensions = this.calculateDimensions();\n      let desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);\n\n      if (this.previousViewPort.startIndex === desiredStartIndex) {\n        if (animationCompletedCallback) {\n          animationCompletedCallback();\n        }\n\n        return;\n      }\n\n      this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);\n    };\n\n    this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);\n  }\n\n  scrollToIndex_internal(index, alignToBeginning = true, additionalOffset = 0, animationMilliseconds = undefined, animationCompletedCallback = undefined) {\n    animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n    let dimensions = this.calculateDimensions();\n    let scroll = this.calculatePadding(index, dimensions) + additionalOffset;\n\n    if (!alignToBeginning) {\n      scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];\n    }\n\n    this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);\n  }\n\n  scrollToPosition(scrollPosition, animationMilliseconds = undefined, animationCompletedCallback = undefined) {\n    scrollPosition += this.getElementsOffset();\n    animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n    let scrollElement = this.getScrollElement();\n    let animationRequest;\n\n    if (this.currentTween) {\n      this.currentTween.stop();\n      this.currentTween = undefined;\n    }\n\n    if (!animationMilliseconds) {\n      this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);\n      this.refresh_internal(false, animationCompletedCallback);\n      return;\n    }\n\n    const tweenConfigObj = {\n      scrollPosition: scrollElement[this._scrollType]\n    };\n    let newTween = new Tween(tweenConfigObj).to({\n      scrollPosition\n    }, animationMilliseconds).easing(Easing.Quadratic.Out).onUpdate(data => {\n      if (isNaN(data.scrollPosition)) {\n        return;\n      }\n\n      this.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);\n      this.refresh_internal(false);\n    }).onStop(() => {\n      cancelAnimationFrame(animationRequest);\n    }).start();\n\n    const animate = time => {\n      if (!newTween[\"isPlaying\"]()) {\n        return;\n      }\n\n      newTween.update(time);\n\n      if (tweenConfigObj.scrollPosition === scrollPosition) {\n        this.refresh_internal(false, animationCompletedCallback);\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => {\n        animationRequest = requestAnimationFrame(animate);\n      });\n    };\n\n    animate();\n    this.currentTween = newTween;\n  }\n\n  getElementSize(element) {\n    let result = element.getBoundingClientRect();\n    let styles = getComputedStyle(element);\n    let marginTop = parseInt(styles['margin-top'], 10) || 0;\n    let marginBottom = parseInt(styles['margin-bottom'], 10) || 0;\n    let marginLeft = parseInt(styles['margin-left'], 10) || 0;\n    let marginRight = parseInt(styles['margin-right'], 10) || 0;\n    return {\n      top: result.top + marginTop,\n      bottom: result.bottom + marginBottom,\n      left: result.left + marginLeft,\n      right: result.right + marginRight,\n      width: result.width + marginLeft + marginRight,\n      height: result.height + marginTop + marginBottom\n    };\n  }\n\n  checkScrollElementResized() {\n    let boundingRect = this.getElementSize(this.getScrollElement());\n    let sizeChanged;\n\n    if (!this.previousScrollBoundingRect) {\n      sizeChanged = true;\n    } else {\n      let widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);\n      let heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);\n      sizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;\n    }\n\n    if (sizeChanged) {\n      this.previousScrollBoundingRect = boundingRect;\n\n      if (boundingRect.width > 0 && boundingRect.height > 0) {\n        this.refresh_internal(false);\n      }\n    }\n  }\n\n  updateDirection() {\n    if (this.horizontal) {\n      this._invisiblePaddingProperty = 'width';\n      this._offsetType = 'offsetLeft';\n      this._pageOffsetType = 'pageXOffset';\n      this._childScrollDim = 'childWidth';\n      this._marginDir = 'margin-left';\n      this._translateDir = 'translateX';\n      this._scrollType = 'scrollLeft';\n    } else {\n      this._invisiblePaddingProperty = 'height';\n      this._offsetType = 'offsetTop';\n      this._pageOffsetType = 'pageYOffset';\n      this._childScrollDim = 'childHeight';\n      this._marginDir = 'margin-top';\n      this._translateDir = 'translateY';\n      this._scrollType = 'scrollTop';\n    }\n  }\n\n  debounce(func, wait) {\n    const throttled = this.throttleTrailing(func, wait);\n\n    const result = function () {\n      throttled['cancel']();\n      throttled.apply(this, arguments);\n    };\n\n    result['cancel'] = function () {\n      throttled['cancel']();\n    };\n\n    return result;\n  }\n\n  throttleTrailing(func, wait) {\n    let timeout = undefined;\n    let _arguments = arguments;\n\n    const result = function () {\n      const _this = this;\n\n      _arguments = arguments;\n\n      if (timeout) {\n        return;\n      }\n\n      if (wait <= 0) {\n        func.apply(_this, _arguments);\n      } else {\n        timeout = setTimeout(function () {\n          timeout = undefined;\n          func.apply(_this, _arguments);\n        }, wait);\n      }\n    };\n\n    result['cancel'] = function () {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n    };\n\n    return result;\n  }\n\n  refresh_internal(itemsArrayModified, refreshCompletedCallback = undefined, maxRunTimes = 2) {\n    //note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).\n    //The default of 2x max will probably be accurate enough without causing too large a performance bottleneck\n    //The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.\n    //Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent this.\n    if (itemsArrayModified && this.previousViewPort && this.previousViewPort.scrollStartPosition > 0) {\n      //if items were prepended, scroll forward to keep same items visible\n      let oldViewPort = this.previousViewPort;\n      let oldViewPortItems = this.viewPortItems;\n      let oldRefreshCompletedCallback = refreshCompletedCallback;\n\n      refreshCompletedCallback = () => {\n        let scrollLengthDelta = this.previousViewPort.scrollLength - oldViewPort.scrollLength;\n\n        if (scrollLengthDelta > 0 && this.viewPortItems) {\n          let oldStartItem = oldViewPortItems[0];\n          let oldStartItemIndex = this.items.findIndex(x => this.compareItems(oldStartItem, x));\n\n          if (oldStartItemIndex > this.previousViewPort.startIndexWithBuffer) {\n            let itemOrderChanged = false;\n\n            for (let i = 1; i < this.viewPortItems.length; ++i) {\n              if (!this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[i])) {\n                itemOrderChanged = true;\n                break;\n              }\n            }\n\n            if (!itemOrderChanged) {\n              this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback);\n              return;\n            }\n          }\n        }\n\n        if (oldRefreshCompletedCallback) {\n          oldRefreshCompletedCallback();\n        }\n      };\n    }\n\n    this.zone.runOutsideAngular(() => {\n      requestAnimationFrame(() => {\n        if (itemsArrayModified) {\n          this.resetWrapGroupDimensions();\n        }\n\n        let viewport = this.calculateViewport();\n        let startChanged = itemsArrayModified || viewport.startIndex !== this.previousViewPort.startIndex;\n        let endChanged = itemsArrayModified || viewport.endIndex !== this.previousViewPort.endIndex;\n        let scrollLengthChanged = viewport.scrollLength !== this.previousViewPort.scrollLength;\n        let paddingChanged = viewport.padding !== this.previousViewPort.padding;\n        let scrollPositionChanged = viewport.scrollStartPosition !== this.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !== this.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !== this.previousViewPort.maxScrollPosition;\n        this.previousViewPort = viewport;\n\n        if (scrollLengthChanged) {\n          this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, this._invisiblePaddingProperty, `${viewport.scrollLength}px`);\n        }\n\n        if (paddingChanged) {\n          if (this.useMarginInsteadOfTranslate) {\n            this.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, `${viewport.padding}px`);\n          } else {\n            this.renderer.setStyle(this.contentElementRef.nativeElement, 'transform', `${this._translateDir}(${viewport.padding}px)`);\n            this.renderer.setStyle(this.contentElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${viewport.padding}px)`);\n          }\n        }\n\n        if (this.headerElementRef) {\n          let scrollPosition = this.getScrollElement()[this._scrollType];\n\n          let containerOffset = this.getElementsOffset();\n          let offset = Math.max(scrollPosition - viewport.padding - containerOffset + this.headerElementRef.nativeElement.clientHeight, 0);\n          this.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`);\n          this.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`);\n        }\n\n        const changeEventArg = startChanged || endChanged ? {\n          startIndex: viewport.startIndex,\n          endIndex: viewport.endIndex,\n          scrollStartPosition: viewport.scrollStartPosition,\n          scrollEndPosition: viewport.scrollEndPosition,\n          startIndexWithBuffer: viewport.startIndexWithBuffer,\n          endIndexWithBuffer: viewport.endIndexWithBuffer,\n          maxScrollPosition: viewport.maxScrollPosition\n        } : undefined;\n\n        if (startChanged || endChanged || scrollPositionChanged) {\n          const handleChanged = () => {\n            // update the scroll list to trigger re-render of components in viewport\n            this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];\n            this.vsUpdate.emit(this.viewPortItems);\n\n            if (startChanged) {\n              this.vsStart.emit(changeEventArg);\n            }\n\n            if (endChanged) {\n              this.vsEnd.emit(changeEventArg);\n            }\n\n            if (startChanged || endChanged) {\n              this.changeDetectorRef.markForCheck();\n              this.vsChange.emit(changeEventArg);\n            }\n\n            if (maxRunTimes > 0) {\n              this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n              return;\n            }\n\n            if (refreshCompletedCallback) {\n              refreshCompletedCallback();\n            }\n          };\n\n          if (this.executeRefreshOutsideAngularZone) {\n            handleChanged();\n          } else {\n            this.zone.run(handleChanged);\n          }\n        } else {\n          if (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {\n            this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n            return;\n          }\n\n          if (refreshCompletedCallback) {\n            refreshCompletedCallback();\n          }\n        }\n      });\n    });\n  }\n\n  getScrollElement() {\n    return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;\n  }\n\n  addScrollEventHandlers() {\n    if (this.isAngularUniversalSSR) {\n      return;\n    }\n\n    let scrollElement = this.getScrollElement();\n    this.removeScrollEventHandlers();\n    this.zone.runOutsideAngular(() => {\n      if (this.parentScroll instanceof Window) {\n        this.disposeScrollHandler = this.renderer.listen('window', 'scroll', this.onScroll);\n        this.disposeResizeHandler = this.renderer.listen('window', 'resize', this.onScroll);\n      } else {\n        this.disposeScrollHandler = this.renderer.listen(scrollElement, 'scroll', this.onScroll);\n\n        if (this._checkResizeInterval > 0) {\n          this.checkScrollElementResizedTimer = setInterval(() => {\n            this.checkScrollElementResized();\n          }, this._checkResizeInterval);\n        }\n      }\n    });\n  }\n\n  removeScrollEventHandlers() {\n    if (this.checkScrollElementResizedTimer) {\n      clearInterval(this.checkScrollElementResizedTimer);\n    }\n\n    if (this.disposeScrollHandler) {\n      this.disposeScrollHandler();\n      this.disposeScrollHandler = undefined;\n    }\n\n    if (this.disposeResizeHandler) {\n      this.disposeResizeHandler();\n      this.disposeResizeHandler = undefined;\n    }\n  }\n\n  getElementsOffset() {\n    if (this.isAngularUniversalSSR) {\n      return 0;\n    }\n\n    let offset = 0;\n\n    if (this.containerElementRef && this.containerElementRef.nativeElement) {\n      offset += this.containerElementRef.nativeElement[this._offsetType];\n    }\n\n    if (this.parentScroll) {\n      let scrollElement = this.getScrollElement();\n      let elementClientRect = this.getElementSize(this.element.nativeElement);\n      let scrollClientRect = this.getElementSize(scrollElement);\n\n      if (this.horizontal) {\n        offset += elementClientRect.left - scrollClientRect.left;\n      } else {\n        offset += elementClientRect.top - scrollClientRect.top;\n      }\n\n      if (!(this.parentScroll instanceof Window)) {\n        offset += scrollElement[this._scrollType];\n      }\n    }\n\n    return offset;\n  }\n\n  countItemsPerWrapGroup() {\n    if (this.isAngularUniversalSSR) {\n      return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);\n    }\n\n    let propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';\n    let children = (this.containerElementRef && this.containerElementRef.nativeElement || this.contentElementRef.nativeElement).children;\n    let childrenLength = children ? children.length : 0;\n\n    if (childrenLength === 0) {\n      return 1;\n    }\n\n    let firstOffset = children[0][propertyName];\n    let result = 1;\n\n    while (result < childrenLength && firstOffset === children[result][propertyName]) {\n      ++result;\n    }\n\n    return result;\n  }\n\n  getScrollStartPosition() {\n    let windowScrollValue = undefined;\n\n    if (this.parentScroll instanceof Window) {\n      windowScrollValue = window[this._pageOffsetType];\n    }\n\n    return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;\n  }\n\n  resetWrapGroupDimensions() {\n    const oldWrapGroupDimensions = this.wrapGroupDimensions;\n    this.invalidateAllCachedMeasurements();\n\n    if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {\n      return;\n    }\n\n    const itemsPerWrapGroup = this.countItemsPerWrapGroup();\n\n    for (let wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {\n      const oldWrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n\n      if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {\n        continue;\n      }\n\n      if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {\n        return;\n      }\n\n      let itemsChanged = false;\n      let arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;\n\n      for (let i = 0; i < itemsPerWrapGroup; ++i) {\n        if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {\n          itemsChanged = true;\n          break;\n        }\n      }\n\n      if (!itemsChanged) {\n        ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;\n        this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;\n      }\n    }\n  }\n\n  calculateDimensions() {\n    let scrollElement = this.getScrollElement();\n    const maxCalculatedScrollBarSize = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll, so we default to this if not set by consuming application\n\n    this.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);\n    this.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);\n    let viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));\n    let viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));\n    let content = this.containerElementRef && this.containerElementRef.nativeElement || this.contentElementRef.nativeElement;\n    let itemsPerWrapGroup = this.countItemsPerWrapGroup();\n    let wrapGroupsPerPage;\n    let defaultChildWidth;\n    let defaultChildHeight;\n\n    if (this.isAngularUniversalSSR) {\n      viewportWidth = this.ssrViewportWidth;\n      viewportHeight = this.ssrViewportHeight;\n      defaultChildWidth = this.ssrChildWidth;\n      defaultChildHeight = this.ssrChildHeight;\n      let itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n      let itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n      wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n    } else if (!this.enableUnequalChildrenSizes) {\n      if (content.children.length > 0) {\n        if (!this.childWidth || !this.childHeight) {\n          if (!this.minMeasuredChildWidth && viewportWidth > 0) {\n            this.minMeasuredChildWidth = viewportWidth;\n          }\n\n          if (!this.minMeasuredChildHeight && viewportHeight > 0) {\n            this.minMeasuredChildHeight = viewportHeight;\n          }\n        }\n\n        let child = content.children[0];\n        let clientRect = this.getElementSize(child);\n        this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);\n        this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);\n      }\n\n      defaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;\n      defaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;\n      let itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n      let itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n      wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n    } else {\n      let scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);\n      let arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;\n      let wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);\n      let maxWidthForWrapGroup = 0;\n      let maxHeightForWrapGroup = 0;\n      let sumOfVisibleMaxWidths = 0;\n      let sumOfVisibleMaxHeights = 0;\n      wrapGroupsPerPage = 0;\n\n      for (let i = 0; i < content.children.length; ++i) {\n        ++arrayStartIndex;\n        let child = content.children[i];\n        let clientRect = this.getElementSize(child);\n        maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);\n        maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);\n\n        if (arrayStartIndex % itemsPerWrapGroup === 0) {\n          let oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n\n          if (oldValue) {\n            --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n            this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;\n            this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;\n          }\n\n          ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n          const items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);\n          this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {\n            childWidth: maxWidthForWrapGroup,\n            childHeight: maxHeightForWrapGroup,\n            items: items\n          };\n          this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;\n          this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;\n\n          if (this.horizontal) {\n            let maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));\n\n            if (scrollOffset > 0) {\n              let scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);\n              maxVisibleWidthForWrapGroup -= scrollOffsetToRemove;\n              scrollOffset -= scrollOffsetToRemove;\n            }\n\n            sumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;\n\n            if (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {\n              ++wrapGroupsPerPage;\n            }\n          } else {\n            let maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));\n\n            if (scrollOffset > 0) {\n              let scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);\n              maxVisibleHeightForWrapGroup -= scrollOffsetToRemove;\n              scrollOffset -= scrollOffsetToRemove;\n            }\n\n            sumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;\n\n            if (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {\n              ++wrapGroupsPerPage;\n            }\n          }\n\n          ++wrapGroupIndex;\n          maxWidthForWrapGroup = 0;\n          maxHeightForWrapGroup = 0;\n        }\n      }\n\n      let averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n      let averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n      defaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;\n      defaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;\n\n      if (this.horizontal) {\n        if (viewportWidth > sumOfVisibleMaxWidths) {\n          wrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);\n        }\n      } else {\n        if (viewportHeight > sumOfVisibleMaxHeights) {\n          wrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);\n        }\n      }\n    }\n\n    let itemCount = this.items.length;\n    let itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;\n    let pageCount_fractional = itemCount / itemsPerPage;\n    let numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);\n    let scrollLength = 0;\n    let defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;\n\n    if (this.enableUnequalChildrenSizes) {\n      let numUnknownChildSizes = 0;\n\n      for (let i = 0; i < numberOfWrapGroups; ++i) {\n        let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n\n        if (childSize) {\n          scrollLength += childSize;\n        } else {\n          ++numUnknownChildSizes;\n        }\n      }\n\n      scrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n    } else {\n      scrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;\n    }\n\n    if (this.headerElementRef) {\n      scrollLength += this.headerElementRef.nativeElement.clientHeight;\n    }\n\n    let viewportLength = this.horizontal ? viewportWidth : viewportHeight;\n    let maxScrollPosition = Math.max(scrollLength - viewportLength, 0);\n    return {\n      itemCount: itemCount,\n      itemsPerWrapGroup: itemsPerWrapGroup,\n      wrapGroupsPerPage: wrapGroupsPerPage,\n      itemsPerPage: itemsPerPage,\n      pageCount_fractional: pageCount_fractional,\n      childWidth: defaultChildWidth,\n      childHeight: defaultChildHeight,\n      scrollLength: scrollLength,\n      viewportLength: viewportLength,\n      maxScrollPosition: maxScrollPosition\n    };\n  }\n\n  calculatePadding(arrayStartIndexWithBuffer, dimensions) {\n    if (dimensions.itemCount === 0) {\n      return 0;\n    }\n\n    let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n    let startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;\n\n    if (!this.enableUnequalChildrenSizes) {\n      return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;\n    }\n\n    let numUnknownChildSizes = 0;\n    let result = 0;\n\n    for (let i = 0; i < startingWrapGroupIndex; ++i) {\n      let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n\n      if (childSize) {\n        result += childSize;\n      } else {\n        ++numUnknownChildSizes;\n      }\n    }\n\n    result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n    return result;\n  }\n\n  calculatePageInfo(scrollPosition, dimensions) {\n    let scrollPercentage = 0;\n\n    if (this.enableUnequalChildrenSizes) {\n      const numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);\n      let totalScrolledLength = 0;\n      let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n\n      for (let i = 0; i < numberOfWrapGroups; ++i) {\n        let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n\n        if (childSize) {\n          totalScrolledLength += childSize;\n        } else {\n          totalScrolledLength += defaultScrollLengthPerWrapGroup;\n        }\n\n        if (scrollPosition < totalScrolledLength) {\n          scrollPercentage = i / numberOfWrapGroups;\n          break;\n        }\n      }\n    } else {\n      scrollPercentage = scrollPosition / dimensions.scrollLength;\n    }\n\n    let startingArrayIndex_fractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;\n    let maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;\n    let arrayStartIndex = Math.min(Math.floor(startingArrayIndex_fractional), maxStart);\n    arrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup\n\n    if (this.stripedTable) {\n      let bufferBoundary = 2 * dimensions.itemsPerWrapGroup;\n\n      if (arrayStartIndex % bufferBoundary !== 0) {\n        arrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);\n      }\n    }\n\n    let arrayEndIndex = Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;\n    let endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;\n\n    if (endIndexWithinWrapGroup > 0) {\n      arrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup\n    }\n\n    if (isNaN(arrayStartIndex)) {\n      arrayStartIndex = 0;\n    }\n\n    if (isNaN(arrayEndIndex)) {\n      arrayEndIndex = 0;\n    }\n\n    arrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);\n    arrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);\n    let bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;\n    let startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);\n    let endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);\n    return {\n      startIndex: arrayStartIndex,\n      endIndex: arrayEndIndex,\n      startIndexWithBuffer: startIndexWithBuffer,\n      endIndexWithBuffer: endIndexWithBuffer,\n      scrollStartPosition: scrollPosition,\n      scrollEndPosition: scrollPosition + dimensions.viewportLength,\n      maxScrollPosition: dimensions.maxScrollPosition\n    };\n  }\n\n  calculateViewport() {\n    let dimensions = this.calculateDimensions();\n    let offset = this.getElementsOffset();\n    let scrollStartPosition = this.getScrollStartPosition();\n\n    if (scrollStartPosition > dimensions.scrollLength + offset && !(this.parentScroll instanceof Window)) {\n      scrollStartPosition = dimensions.scrollLength;\n    } else {\n      scrollStartPosition -= offset;\n    }\n\n    scrollStartPosition = Math.max(0, scrollStartPosition);\n    let pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);\n    let newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);\n    let newScrollLength = dimensions.scrollLength;\n    return {\n      startIndex: pageInfo.startIndex,\n      endIndex: pageInfo.endIndex,\n      startIndexWithBuffer: pageInfo.startIndexWithBuffer,\n      endIndexWithBuffer: pageInfo.endIndexWithBuffer,\n      padding: Math.round(newPadding),\n      scrollLength: Math.round(newScrollLength),\n      scrollStartPosition: pageInfo.scrollStartPosition,\n      scrollEndPosition: pageInfo.scrollEndPosition,\n      maxScrollPosition: pageInfo.maxScrollPosition\n    };\n  }\n\n};\n\nVirtualScrollerComponent.ɵfac = function VirtualScrollerComponent_Factory(t) {\n  return new (t || VirtualScrollerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject('virtual-scroller-default-options', 8));\n};\n\nVirtualScrollerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n  type: VirtualScrollerComponent,\n  selectors: [[\"virtual-scroller\"], [\"\", \"virtualScroller\", \"\"]],\n  contentQueries: function VirtualScrollerComponent_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 5, ElementRef);\n      ɵngcc0.ɵɵcontentQuery(dirIndex, _c1, 5, ElementRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerElementRef = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerElementRef = _t.first);\n    }\n  },\n  viewQuery: function VirtualScrollerComponent_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵviewQuery(_c2, 7, ElementRef);\n      ɵngcc0.ɵɵviewQuery(_c3, 7, ElementRef);\n    }\n\n    if (rf & 2) {\n      let _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentElementRef = _t.first);\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.invisiblePaddingElementRef = _t.first);\n    }\n  },\n  hostVars: 8,\n  hostBindings: function VirtualScrollerComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"horizontal\", ctx.horizontal)(\"vertical\", !ctx.horizontal)(\"selfScroll\", !ctx.parentScroll)(\"rtl\", ctx.RTL);\n    }\n  },\n  inputs: {\n    executeRefreshOutsideAngularZone: \"executeRefreshOutsideAngularZone\",\n    RTL: \"RTL\",\n    useMarginInsteadOfTranslate: \"useMarginInsteadOfTranslate\",\n    ssrViewportWidth: \"ssrViewportWidth\",\n    ssrViewportHeight: \"ssrViewportHeight\",\n    compareItems: \"compareItems\",\n    scrollThrottlingTime: \"scrollThrottlingTime\",\n    scrollDebounceTime: \"scrollDebounceTime\",\n    scrollAnimationTime: \"scrollAnimationTime\",\n    scrollbarWidth: \"scrollbarWidth\",\n    scrollbarHeight: \"scrollbarHeight\",\n    checkResizeInterval: \"checkResizeInterval\",\n    resizeBypassRefreshThreshold: \"resizeBypassRefreshThreshold\",\n    modifyOverflowStyleOfParentScroll: \"modifyOverflowStyleOfParentScroll\",\n    stripedTable: \"stripedTable\",\n    horizontal: \"horizontal\",\n    enableUnequalChildrenSizes: \"enableUnequalChildrenSizes\",\n    bufferAmount: \"bufferAmount\",\n    items: \"items\",\n    parentScroll: \"parentScroll\",\n    childWidth: \"childWidth\",\n    childHeight: \"childHeight\",\n    ssrChildWidth: \"ssrChildWidth\",\n    ssrChildHeight: \"ssrChildHeight\"\n  },\n  outputs: {\n    vsUpdate: \"vsUpdate\",\n    vsChange: \"vsChange\",\n    vsStart: \"vsStart\",\n    vsEnd: \"vsEnd\"\n  },\n  exportAs: [\"virtualScroller\"],\n  features: [ɵngcc0.ɵɵNgOnChangesFeature],\n  ngContentSelectors: _c4,\n  decls: 5,\n  vars: 0,\n  consts: [[1, \"total-padding\"], [\"invisiblePadding\", \"\"], [1, \"scrollable-content\"], [\"content\", \"\"]],\n  template: function VirtualScrollerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelement(0, \"div\", 0, 1);\n      ɵngcc0.ɵɵelementStart(2, \"div\", 2, 3);\n      ɵngcc0.ɵɵprojection(4);\n      ɵngcc0.ɵɵelementEnd();\n    }\n  },\n  styles: [\"[_nghost-%COMP%] {\\n      position: relative;\\n\\t  display: block;\\n      -webkit-overflow-scrolling: touch;\\n    }\\n\\n\\t.horizontal.selfScroll[_nghost-%COMP%] {\\n      overflow-y: visible;\\n      overflow-x: auto;\\n\\t}\\n\\t\\n\\t.horizontal.selfScroll.rtl[_nghost-%COMP%] {\\n\\t\\ttransform: scaleX(-1);\\n\\t}\\n\\n\\t.vertical.selfScroll[_nghost-%COMP%] {\\n      overflow-y: auto;\\n      overflow-x: visible;\\n\\t}\\n\\n    .scrollable-content[_ngcontent-%COMP%] {\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n      max-width: 100vw;\\n      max-height: 100vh;\\n      position: absolute;\\n    }\\n\\n\\t.scrollable-content[_ngcontent-%COMP%]     > * {\\n\\t\\tbox-sizing: border-box;\\n\\t}\\n\\n\\t.horizontal[_nghost-%COMP%] {\\n\\t\\twhite-space: nowrap;\\n\\t}\\n\\n\\t.horizontal[_nghost-%COMP%]   .scrollable-content[_ngcontent-%COMP%] {\\n\\t\\tdisplay: flex;\\n\\t}\\n\\n\\t.horizontal[_nghost-%COMP%]   .scrollable-content[_ngcontent-%COMP%]     > * {\\n\\t\\tflex-shrink: 0;\\n\\t\\tflex-grow: 0;\\n\\t\\twhite-space: initial;\\n\\t}\\n\\n\\t.horizontal.rtl[_nghost-%COMP%]   .scrollable-content[_ngcontent-%COMP%]     > * {\\n\\t\\ttransform:scaleX(-1);\\n\\t}\\n\\t\\n    .total-padding[_ngcontent-%COMP%] {\\n      width: 1px;\\n      opacity: 0;\\n    }\\n\\n    .horizontal[_nghost-%COMP%]   .total-padding[_ngcontent-%COMP%] {\\n      height: 100%;\\n    }\"]\n});\n\nVirtualScrollerComponent.ctorParameters = () => [{\n  type: ElementRef\n}, {\n  type: Renderer2\n}, {\n  type: NgZone\n}, {\n  type: ChangeDetectorRef\n}, {\n  type: Object,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: ['virtual-scroller-default-options']\n  }]\n}];\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"executeRefreshOutsideAngularZone\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"enableUnequalChildrenSizes\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"RTL\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"useMarginInsteadOfTranslate\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"modifyOverflowStyleOfParentScroll\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"stripedTable\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"scrollbarWidth\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"scrollbarHeight\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"childWidth\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"childHeight\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"ssrChildWidth\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"ssrChildHeight\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"ssrViewportWidth\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"ssrViewportHeight\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"bufferAmount\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"scrollAnimationTime\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"resizeBypassRefreshThreshold\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"scrollThrottlingTime\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"scrollDebounceTime\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"checkResizeInterval\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"items\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"compareItems\", void 0);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"horizontal\", null);\n\n__decorate([Input()], VirtualScrollerComponent.prototype, \"parentScroll\", null);\n\n__decorate([Output()], VirtualScrollerComponent.prototype, \"vsUpdate\", void 0);\n\n__decorate([Output()], VirtualScrollerComponent.prototype, \"vsChange\", void 0);\n\n__decorate([Output()], VirtualScrollerComponent.prototype, \"vsStart\", void 0);\n\n__decorate([Output()], VirtualScrollerComponent.prototype, \"vsEnd\", void 0);\n\n__decorate([ViewChild('content', {\n  read: ElementRef,\n  static: true\n})], VirtualScrollerComponent.prototype, \"contentElementRef\", void 0);\n\n__decorate([ViewChild('invisiblePadding', {\n  read: ElementRef,\n  static: true\n})], VirtualScrollerComponent.prototype, \"invisiblePaddingElementRef\", void 0);\n\n__decorate([ContentChild('header', {\n  read: ElementRef,\n  static: false\n})], VirtualScrollerComponent.prototype, \"headerElementRef\", void 0);\n\n__decorate([ContentChild('container', {\n  read: ElementRef,\n  static: false\n})], VirtualScrollerComponent.prototype, \"containerElementRef\", void 0);\n\nVirtualScrollerComponent = __decorate([__param(4, Inject(PLATFORM_ID)), __param(5, Optional()), __param(5, Inject('virtual-scroller-default-options'))], VirtualScrollerComponent);\nlet VirtualScrollerModule = class VirtualScrollerModule {};\n\nVirtualScrollerModule.ɵfac = function VirtualScrollerModule_Factory(t) {\n  return new (t || VirtualScrollerModule)();\n};\n\nVirtualScrollerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: VirtualScrollerModule\n});\nVirtualScrollerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  providers: [{\n    provide: 'virtual-scroller-default-options',\n    useFactory: VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY\n  }],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VirtualScrollerModule, {\n    declarations: function () {\n      return [VirtualScrollerComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [VirtualScrollerComponent];\n    }\n  });\n})();\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY, VirtualScrollerComponent, VirtualScrollerModule }; //# sourceMappingURL=ngx-virtual-scroller.js.map","map":null,"metadata":{},"sourceType":"module"}