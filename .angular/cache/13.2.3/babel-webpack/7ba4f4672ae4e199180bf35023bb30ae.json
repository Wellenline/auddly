{"ast":null,"code":"import { empty, merge, of, Subject } from 'rxjs';\nimport { delay, finalize, tap, publishReplay, refCount } from 'rxjs/operators';\nimport { DEFAULT_CACHE_RESOLVER, GlobalCacheConfig, DEFAULT_HASHER } from './common';\nexport const globalCacheBusterNotifier = new Subject();\nexport function Cacheable(cacheConfig = {}) {\n  return function (_target, _propertyKey, propertyDescriptor) {\n    const cacheKey = cacheConfig.cacheKey || _target.constructor.name + '#' + _propertyKey;\n    const oldMethod = propertyDescriptor.value;\n\n    if (propertyDescriptor && propertyDescriptor.value) {\n      let storageStrategy = !cacheConfig.storageStrategy ? new GlobalCacheConfig.storageStrategy() : new cacheConfig.storageStrategy();\n      const pendingCachePairs = [];\n\n      if (cacheConfig.cacheModifier) {\n        cacheConfig.cacheModifier.subscribe(callback => storageStrategy.addMany(callback(storageStrategy.getAll(cacheKey, this)), cacheKey, this));\n      }\n      /**\n       * subscribe to the globalCacheBuster\n       * if a custom cacheBusterObserver is passed, subscribe to it as well\n       * subscribe to the cacheBusterObserver and upon emission, clear all caches\n       */\n\n\n      merge(globalCacheBusterNotifier.asObservable(), cacheConfig.cacheBusterObserver ? cacheConfig.cacheBusterObserver : empty()).subscribe(_ => {\n        storageStrategy.removeAll(cacheKey, this);\n        pendingCachePairs.length = 0;\n      });\n      const cacheResolver = cacheConfig.cacheResolver || GlobalCacheConfig.cacheResolver;\n      cacheConfig.cacheResolver = cacheResolver ? cacheResolver : DEFAULT_CACHE_RESOLVER;\n      const cacheHasher = cacheConfig.cacheHasher || GlobalCacheConfig.cacheHasher;\n      cacheConfig.cacheHasher = cacheHasher ? cacheHasher : DEFAULT_HASHER;\n      /* use function instead of an arrow function to keep context of invocation */\n\n      propertyDescriptor.value = function (...parameters) {\n        const cachePairs = storageStrategy.getAll(cacheKey, this);\n        let cacheParameters = cacheConfig.cacheHasher(parameters);\n\n        let _foundCachePair = cachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n        const _foundPendingCachePair = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n        /**\n         * check if maxAge is passed and cache has actually expired\n         */\n\n\n        if ((cacheConfig.maxAge || GlobalCacheConfig.maxAge) && _foundCachePair && _foundCachePair.created) {\n          if (new Date().getTime() - new Date(_foundCachePair.created).getTime() > (cacheConfig.maxAge || GlobalCacheConfig.maxAge)) {\n            /**\n             * cache duration has expired - remove it from the cachePairs array\n             */\n            storageStrategy.remove ? storageStrategy.remove(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.removeAtIndex(cachePairs.indexOf(_foundCachePair), cacheKey, this);\n            _foundCachePair = null;\n          } else if (cacheConfig.slidingExpiration || GlobalCacheConfig.slidingExpiration) {\n            /**\n             * renew cache duration\n             */\n            _foundCachePair.created = new Date();\n            storageStrategy.update ? storageStrategy.update(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this) : storageStrategy.updateAtIndex(cachePairs.indexOf(_foundCachePair), _foundCachePair, cacheKey, this);\n          }\n        }\n\n        if (_foundCachePair) {\n          const cached$ = of(_foundCachePair.response);\n          return cacheConfig.async ? cached$.pipe(delay(0)) : cached$;\n        } else if (_foundPendingCachePair) {\n          return _foundPendingCachePair.response;\n        } else {\n          const response$ = oldMethod.call(this, ...parameters).pipe(finalize(() => {\n            /**\n             * if there has been an observable cache pair for these parameters, when it completes or errors, remove it\n             */\n            const _pendingCachePairToRemove = pendingCachePairs.find(cp => cacheConfig.cacheResolver(cp.parameters, cacheParameters));\n\n            pendingCachePairs.splice(pendingCachePairs.indexOf(_pendingCachePairToRemove), 1);\n          }), tap(response => {\n            /**\n             * if maxCacheCount has not been passed, just shift the cachePair to make room for the new one\n             * if maxCacheCount has been passed, respect that and only shift the cachePairs if the new cachePair will make them exceed the count\n             */\n            if (!cacheConfig.shouldCacheDecider || cacheConfig.shouldCacheDecider(response)) {\n              if (!(cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) === 1 || (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) && (cacheConfig.maxCacheCount || GlobalCacheConfig.maxCacheCount) < cachePairs.length + 1) {\n                storageStrategy.remove ? storageStrategy.remove(0, cachePairs[0], cacheKey, this) : storageStrategy.removeAtIndex(0, cacheKey, this);\n              }\n\n              storageStrategy.add({\n                parameters: cacheParameters,\n                response,\n                created: cacheConfig.maxAge || GlobalCacheConfig.maxAge ? new Date() : null\n              }, cacheKey, this);\n            }\n          }), publishReplay(1), refCount());\n          /**\n           * cache the stream\n           */\n\n          pendingCachePairs.push({\n            parameters: cacheParameters,\n            response: response$,\n            created: new Date()\n          });\n          return response$;\n        }\n      };\n    }\n\n    return propertyDescriptor;\n  };\n}\n; //# sourceMappingURL=cacheable.decorator.js.map","map":null,"metadata":{},"sourceType":"module"}